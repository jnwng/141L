res 64              # beginning address of our hash table - 1
cpout $s1
res 128             # store last index of hash table
cpout $c2           # put in $c2 for comparison later
res 63
cpout $t0           # index = 63 (start_index-1)
// Walking through array

loop:
res 128
// fetch routine, iterate through hashmap for index of a value, returns
// index in $s0

fetch:
res 0
cpout $t0           # $t0 marks the end of the hash table 
cpout $t2           # this keeps track of our place in the hashtable

loop2:
res 152             # here we check if we have hit the end of the array
load $c1
cpin $s1
cpout $c2
res end
cpin $t1
branch =            # we end if we have
cpin $t0            # we want the value of our arrayâ€™s current index
load $c1            # load the value at that index into $c1
cpin $s1            # copy the address of our desired key to be found
load $c2            # load the value into $c2
res 2               # increment the hash table bookmark
add $t2
cpout $t2           # copy in the hash key address into $s0
cpout $s0
res new_entry       # if $t0 = $s1 we hit the end, make a new entry
cpin $t1             
branch =
cpin $t2
load $c1            #c1 is the current hash table entry
res inc     
cpin $t1           
branch =            # if the hash table entry is the key, we inc   
res 16
add $s1
cpout $s1
res loop2           # increment the array index, and loop
cpin $t1
jump $t1

new_entry:
cpin $t0
store $s1           # store new key
res 1
cpout $t3
res 1
add $t0
store $t3 
cpin $s1
cpout $s0
res 16
add $s1
cpout $s1
res loop
cpyin $t1
jump $t1

inc:
cpin $t0
cpout $t3
fetch $s0          # get index value of integer in $s0 and put it in $s0
res 1
add $s0            # key address + 1 is the counter value
copyout $t1        # store address of this counter value for now
load $t0           # loaded count of integer in $t0
res 1
add $t0            # count + 1
copyout $t0        
copyin $t1
store $t0          # map[x] = map[x]+1
res 16
add $s1
cpout $s1
res loop
cpyin $t1
cpyin $t3
cpyout $t0
jump $t1

end:
res 1
cpout $s0
cpout $s1

findlargest:      # iterating through the hash table
cpin $t0          # res = $t0
cpout $c1         # c1 = $t0
cpin $s1          # res = $s1
load $c2          # c2 = value at s1
res return
cpout $t1         #t1 is the label return
branch =
res 1
add $s0            
load $c1
res 2
add $s1
load $c2
res gt
cpout $t1
branch >
res lt
cpout $t1
jump $t1

gt:
res -1
add $c1
cpout $s0
res findlargest
cpout $t1
jump $t1

lt:
res -1
add $c2
cpout $s0
res findlargest
cpout $t1
jump $t1

return:
res -1
add $s0
load $s0
cpin $s0
res 64
load $s0
halt